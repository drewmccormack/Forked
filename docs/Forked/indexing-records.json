[{"headings":[],"title":"init(name:)","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Fork\/init(name:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"summary":"Initialize a fork with a given unique name.","kind":"symbol","rawIndexableTextContent":"Initialize a fork with a given unique name. "},{"headings":[],"title":"next()","rawIndexableTextContent":"Increase the timestamp by 1 ","summary":"Increase the timestamp by 1","kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/next()","interfaceLanguage":"swift"}}},{"summary":"In general, 3-way merges are used in Forked. But when bootstrapping, there can be times when no common ancestor exists. Effectively we have to merge together unrelated values. For example, if you install an app on two offline devices, insert some data on each, and then take them online to sync. In this scenario, there is no common ancestor, but it would be nice to keep the data entered on each device. An even trickier case arises if two devices are fully synced up, but then the cloud data is reset. Effectively, the two data sets are now unrelated, and if you start them syncing again, the history relating them is lost, and there is no common ancestor. You can choose one or the other, but just blindly merging the two will lead to duplications (how often have we seen that in apps like Contacts?)","title":"salvaging(from:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Mergeable\/salvaging(from:)","interfaceLanguage":"swift"}},"headings":["Discussion"],"kind":"symbol","rawIndexableTextContent":"In general, 3-way merges are used in Forked. But when bootstrapping, there can be times when no common ancestor exists. Effectively we have to merge together unrelated values. For example, if you install an app on two offline devices, insert some data on each, and then take them online to sync. In this scenario, there is no common ancestor, but it would be nice to keep the data entered on each device. An even trickier case arises if two devices are fully synced up, but then the cloud data is reset. Effectively, the two data sets are now unrelated, and if you start them syncing again, the history relating them is lost, and there is no common ancestor. You can choose one or the other, but just blindly merging the two will lead to duplications (how often have we seen that in apps like Contacts?)  Discussion That’s a lot of introduction, but it sets up this function. This function is effectively a 2-way merge. By default, it just returns self, which is considered the dominant copy of the data. But if you need special handling to bootstrap, you can “salvage” data from other and merge it in. It is even possible to setup a 3-way merge where you construct an initial value and use that as the common ancestor, but this may not work well for all properties. Often a combination of approaches is best for salvaging, eg, starting with a 3-way merge against the initial value, and then copying in properties from self where this 3-way merge doesn’t do what you want."},{"title":"MergeAction.fastForward","headings":[],"rawIndexableTextContent":"The destination fork is behind, and it has no new commits itself. So the destination fork version was simply made equal to the newer fork version. This is known as a “fast forward”. ","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/MergeAction\/fastForward"},"type":"topLevelPage"},"summary":"The destination fork is behind, and it has no new commits itself. So the destination fork version was simply made equal to the newer fork version. This is known as a “fast forward”.","kind":"symbol"},{"headings":["Discussion"],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/MergeAction\/!=(_:_:)","interfaceLanguage":"swift"}},"title":"!=(_:_:)","summary":"Returns a Boolean value indicating whether two values are not equal.","kind":"symbol","rawIndexableTextContent":"Returns a Boolean value indicating whether two values are not equal.  A value to compare. Another value to compare. Discussion Inequality is the inverse of equality. For any values a and b, a != b implies that a == b is false. This is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable."},{"summary":"If the version is less or equal to the currentVersion it is considered to be known. Ie, it is a version from the past or a current version, and we can handle this version. It can be properly migrated.","headings":[],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/VersionedModel\/canLoadModelVersion","interfaceLanguage":"swift"}},"kind":"symbol","rawIndexableTextContent":"If the version is less or equal to the currentVersion it is considered to be known. Ie, it is a version from the past or a current version, and we can handle this version. It can be properly migrated. ","title":"canLoadModelVersion"},{"headings":[],"rawIndexableTextContent":"","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/CommitContent\/Decodable-Implementations","interfaceLanguage":"swift"},"type":"topLevelPage"},"kind":"article","summary":"","title":"Decodable Implementations"},{"kind":"symbol","summary":"","headings":[],"title":"load()","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/load()"},"type":"topLevelPage"},"rawIndexableTextContent":" "},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/FileRepository\/versions(storedIn:)","interfaceLanguage":"swift"}},"kind":"symbol","rawIndexableTextContent":" ","summary":"","headings":[],"title":"versions(storedIn:)"},{"headings":[],"kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Repository\/create(_:withInitialCommit:)"}},"title":"create(_:withInitialCommit:)","summary":"Creates a fork providing an initial commit to populate it with. Throws if the fork is already present.","rawIndexableTextContent":"Creates a fork providing an initial commit to populate it with. Throws if the fork is already present. "},{"kind":"symbol","title":"!=(_:_:)","headings":["Discussion"],"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Commit\/!=(_:_:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"rawIndexableTextContent":"Returns a Boolean value indicating whether two values are not equal.  A value to compare. Another value to compare. Discussion Inequality is the inverse of equality. For any values a and b, a != b implies that a == b is false. This is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.","summary":"Returns a Boolean value indicating whether two values are not equal."},{"summary":"Returns a closed range that contains both of its bounds.","rawIndexableTextContent":"Returns a closed range that contains both of its bounds.  The lower bound for the range. The upper bound for the range. Discussion Use the closed range operator (...) to create a closed range of any type that conforms to the Comparable protocol. This example creates a ClosedRange<Character> from “a” up to, and including, “z”.  minimum <= maximum.","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/...(_:_:)","interfaceLanguage":"swift"}},"headings":["Discussion"],"kind":"symbol","title":"...(_:_:)"},{"headings":["Return Value","Discussion"],"title":">=(_:_:)","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Version\/_=(_:_:)-9tu3k"}},"kind":"symbol","summary":"Returns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.","rawIndexableTextContent":"Returns a Boolean value indicating whether the value of the first argument is greater than or equal to that of the second argument.  A value to compare. Another value to compare. Return Value true if lhs is greater than or equal to rhs; otherwise, false. Discussion This is the default implementation of the greater-than-or-equal-to operator (>=) for any type that conforms to Comparable."},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Repository\/delete(_:)","interfaceLanguage":"swift"}},"kind":"symbol","headings":[],"summary":"Delete an existing fork. Throws if it isn’t present.","rawIndexableTextContent":"Delete an existing fork. Throws if it isn’t present. ","title":"delete(_:)"},{"title":"initialVersion","headings":[],"kind":"symbol","summary":"Big bang version of every ForkedResource. Effectively, it is ancient history. Also used as the initial value of any newly created branch","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Version\/initialVersion"},"type":"topLevelPage"},"rawIndexableTextContent":"Big bang version of every ForkedResource. Effectively, it is ancient history. Also used as the initial value of any newly created branch "},{"kind":"symbol","title":"...(_:)","headings":["Discussion"],"rawIndexableTextContent":"Returns a partial range up to, and including, its upper bound.  The upper bound for the range. Discussion Use the prefix closed range operator (prefix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeThrough<Double> instance that includes any value less than or equal to 5.0.  You can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, and including, the partial range’s upper bound.  maximum must compare equal to itself (i.e. cannot be NaN).","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/...(_:)-1nziq","interfaceLanguage":"swift"}},"summary":"Returns a partial range up to, and including, its upper bound."},{"summary":"Update the contents of a fork with a new resource value. Will create a commit, and return the Version.","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/update(_:with:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"update(_:with:)","headings":[],"kind":"symbol","rawIndexableTextContent":"Update the contents of a fork with a new resource value. Will create a commit, and return the Version. "},{"kind":"symbol","headings":[],"rawIndexableTextContent":"Merges other forks into main, and then main into the target fork, so it has up-to-date data from all other forks. You can pass in .main if you want to merge all other forks into .main. ","summary":"Merges other forks into main, and then main into the target fork, so it has up-to-date data from all other forks. You can pass in .main if you want to merge all other forks into .main.","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mergeAllForks(into:)-30zos"},"type":"topLevelPage"},"title":"mergeAllForks(into:)"},{"summary":"","rawIndexableTextContent":" ","title":"<(_:_:)","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Version\/_(_:_:)"},"type":"topLevelPage"},"headings":[],"kind":"symbol"},{"title":"create(_:withInitialCommit:)","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/create(_:withInitialCommit:)"}},"kind":"symbol","summary":"","headings":[],"rawIndexableTextContent":" "},{"headings":[],"rawIndexableTextContent":"This manages forks of a resource. It facilitiates concurrent changes to a single resource, and provides a systematic approach for merging changes, with support for 3-way merging. ","title":"ForkedResource","kind":"symbol","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource"},"type":"topLevelPage"},"summary":"This manages forks of a resource. It facilitiates concurrent changes to a single resource, and provides a systematic approach for merging changes, with support for 3-way merging."},{"title":"Equatable Implementations","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/MergeAction\/Equatable-Implementations","interfaceLanguage":"swift"}},"summary":"","headings":[],"rawIndexableTextContent":"","kind":"article"},{"headings":[],"kind":"symbol","summary":"If needed, the repo can store data persistently at this point (or do nothing) Do not call this unless you are using a type that is persistable, otherwise you will get a fatalError.","rawIndexableTextContent":"If needed, the repo can store data persistently at this point (or do nothing) Do not call this unless you are using a type that is persistable, otherwise you will get a fatalError. ","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Persistent\/persist()","interfaceLanguage":"swift"}},"title":"persist()"},{"title":"CommitContent.none","summary":"The content is not present. Perhaps it has not been added yet, or it may have been removed.","headings":[],"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/CommitContent\/none"}},"rawIndexableTextContent":"The content is not present. Perhaps it has not been added yet, or it may have been removed. ","kind":"symbol"},{"location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Persistent"},"type":"topLevelPage"},"summary":"","title":"Persistent","rawIndexableTextContent":" ","headings":[],"kind":"symbol"},{"title":"performAtomically(_:)","kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/performAtomically(_:)"}},"summary":"If you want to perform a series of calls as a single transaction, preventing other threads from changing anything between calls, use this to group the transaction of calls. Note that reentrance of this method from the same thread will lead to deadlock. It is best not to execute long running code in the block, because all other interactions with the ForkedResource will block waiting.","headings":[],"rawIndexableTextContent":"If you want to perform a series of calls as a single transaction, preventing other threads from changing anything between calls, use this to group the transaction of calls. Note that reentrance of this method from the same thread will lead to deadlock. It is best not to execute long running code in the block, because all other interactions with the ForkedResource will block waiting. "},{"headings":[],"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/syncAllForks()-88teh"}},"kind":"symbol","title":"syncAllForks()","summary":"Merges all forks so they are all at the same version. This involves merging all forks into the main fork first, and then merging the main fork into all other forks.","rawIndexableTextContent":"Merges all forks so they are all at the same version. This involves merging all forks into the main fork first, and then merging the main fork into all other forks. "},{"title":"mainVersion(isSameAsVersionIn:)","summary":"","kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mainVersion(isSameAsVersionIn:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":[],"rawIndexableTextContent":" "},{"kind":"symbol","summary":"A type representing a named fork.","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Fork","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"Fork","rawIndexableTextContent":"A type representing a named fork. ","headings":[]},{"kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Mergeable\/merged(withSubordinate:commonAncestor:)"}},"summary":"Performs a 3-way merge, where self and other are the most recent versions, and commonAncestor is from a point in the past at which time the histories diverged. By comparing the recent values to the ancestor, you can determine what changed in each fork, and decide how to merge. Where it is not possible to merge changes from each, self should be considered the dominant fork, and other subordinate. If you must choose, choose self.","title":"merged(withSubordinate:commonAncestor:)","headings":[],"rawIndexableTextContent":"Performs a 3-way merge, where self and other are the most recent versions, and commonAncestor is from a point in the past at which time the histories diverged. By comparing the recent values to the ancestor, you can determine what changed in each fork, and decide how to merge. Where it is not possible to merge changes from each, self should be considered the dominant fork, and other subordinate. If you must choose, choose self. "},{"rawIndexableTextContent":" ","title":"removeCommit(at:from:)","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/FileRepository\/removeCommit(at:from:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":[],"kind":"symbol","summary":""},{"kind":"symbol","title":"init(repository:)","summary":"Initialize the ForkedResource with a repository. If the repository is new, and has no main fork, one will be added with an initial commit.","headings":["Discussion"],"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/init(repository:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"rawIndexableTextContent":"Initialize the ForkedResource with a repository. If the repository is new, and has no main fork, one will be added with an initial commit.  The repository to use for storing the forked resource data Discussion An error if creating the main fork or accessing repository data fails"},{"kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/_(_:_:)-2167f","interfaceLanguage":"swift"}},"title":">(_:_:)","headings":["Discussion"],"rawIndexableTextContent":"Returns a Boolean value indicating whether the value of the first argument is greater than that of the second argument.  A value to compare. Another value to compare. Discussion This is the default implementation of the greater-than operator (>) for any type that conforms to Comparable.","summary":"Returns a Boolean value indicating whether the value of the first argument is greater than that of the second argument."},{"summary":"Returns whether main has commits that haven’t been merged into the fork yet.","kind":"symbol","title":"hasUnmergedCommitsInMain(for:)","headings":[],"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/hasUnmergedCommitsInMain(for:)"}},"rawIndexableTextContent":"Returns whether main has commits that haven’t been merged into the fork yet. "},{"title":"Error.attemptToCreateExistingFork(_:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Error\/attemptToCreateExistingFork(_:)","interfaceLanguage":"swift"}},"kind":"symbol","summary":"","headings":[],"rawIndexableTextContent":" "},{"headings":[],"kind":"article","rawIndexableTextContent":"","summary":"","title":"Decodable Implementations","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/Decodable-Implementations","interfaceLanguage":"swift"}}},{"title":"name","headings":[],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Fork\/name","interfaceLanguage":"swift"}},"summary":"The name of the fork","rawIndexableTextContent":"The name of the fork ","kind":"symbol"},{"title":"Repository","kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Repository","interfaceLanguage":"swift"}},"summary":"This is storage for the ForkedResource. It could be persisted on disk, or just kept in memory. This type does not understand any of the mechanisms of forking and merging. That is all handled by the ForkedResource, which also ensures correct multi-threading behavior. Classes conforming to this type simply have to setup a storage mechanism, and handle the requests, keeping commits assigned to forks.","headings":[],"rawIndexableTextContent":"This is storage for the ForkedResource. It could be persisted on disk, or just kept in memory. This type does not understand any of the mechanisms of forking and merging. That is all handled by the ForkedResource, which also ensures correct multi-threading behavior. Classes conforming to this type simply have to setup a storage mechanism, and handle the requests, keeping commits assigned to forks. "},{"title":"MergeAction.none","headings":[],"kind":"symbol","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/MergeAction\/none"},"type":"topLevelPage"},"summary":"No action was taken. The two forks were already at the same version.","rawIndexableTextContent":"No action was taken. The two forks were already at the same version. "},{"kind":"symbol","title":"versions(storedIn:)","headings":[],"rawIndexableTextContent":" ","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/versions(storedIn:)","interfaceLanguage":"swift"}},"summary":""},{"headings":[],"rawIndexableTextContent":" ","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Error\/attemptToDeleteProtectedFork(_:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"kind":"symbol","title":"Error.attemptToDeleteProtectedFork(_:)","summary":""},{"rawIndexableTextContent":"","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkChange\/Equatable-Implementations","interfaceLanguage":"swift"}},"kind":"article","title":"Equatable Implementations","summary":"","headings":[]},{"kind":"article","rawIndexableTextContent":"","summary":"","headings":[],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Error\/Error-Implementations","interfaceLanguage":"swift"}},"title":"Error Implementations"},{"rawIndexableTextContent":"Brings main and the other fork to the same version by first merging from the other fork into main, and then merging from main into the other fork (fast forward). This particular overload handles merges of  Mergeable resources. To sync up all forks, just pass all forks to this func, including .main. The main fork is ignored when merging. ","headings":[],"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/syncMain(with:)-uing"}},"title":"syncMain(with:)","kind":"symbol","summary":"Brings main and the other fork to the same version by first merging from the other fork into main, and then merging from main into the other fork (fast forward). This particular overload handles merges of  Mergeable resources. To sync up all forks, just pass all forks to this func, including .main. The main fork is ignored when merging."},{"kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/forks","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"forks","rawIndexableTextContent":" ","summary":"","headings":[]},{"title":"init(from:)","summary":"","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/init(from:)","interfaceLanguage":"swift"}},"headings":[],"rawIndexableTextContent":" ","kind":"symbol"},{"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Error\/attemptToDeleteAllDataFromMainFork","interfaceLanguage":"swift"},"type":"topLevelPage"},"rawIndexableTextContent":" ","headings":[],"title":"Error.attemptToDeleteAllDataFromMainFork","summary":"","kind":"symbol"},{"kind":"symbol","headings":[],"rawIndexableTextContent":" ","title":"Error.attemptToRestartMainFork","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Error\/attemptToRestartMainFork"}},"summary":""},{"kind":"symbol","title":"resource","summary":"","headings":[],"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/CommitContent\/resource"}},"rawIndexableTextContent":" "},{"kind":"symbol","summary":"","title":"Optional","headings":[],"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Swift\/Optional"}},"rawIndexableTextContent":" "},{"kind":"symbol","title":"==(_:_:)","summary":"","headings":[],"rawIndexableTextContent":" ","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Version\/==(_:_:)"},"type":"topLevelPage"}},{"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Commit\/==(_:_:)"}},"kind":"symbol","title":"==(_:_:)","headings":[],"summary":"","rawIndexableTextContent":" "},{"title":"delete(_:)","summary":"Delete an existing fork. If the fork does not exist, it will throw.","headings":[],"rawIndexableTextContent":"Delete an existing fork. If the fork does not exist, it will throw. ","kind":"symbol","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/delete(_:)"},"type":"topLevelPage"}},{"location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Persistent\/load()-343pg"},"type":"topLevelPage"},"kind":"symbol","title":"load()","summary":"","headings":[],"rawIndexableTextContent":" "},{"title":"Error.attemptToAccessNonExistentCommitInFork(_:)","kind":"symbol","headings":[],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Error\/attemptToAccessNonExistentCommitInFork(_:)","interfaceLanguage":"swift"}},"summary":"","rawIndexableTextContent":" "},{"rawIndexableTextContent":"The only fork created by default. All other forks can be merged with the main, but not directly with each other. It acts as the central hub of the wheel of forks. ","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Fork\/main","interfaceLanguage":"swift"}},"title":"main","kind":"symbol","summary":"The only fork created by default. All other forks can be merged with the main, but not directly with each other. It acts as the central hub of the wheel of forks.","headings":[]},{"summary":"","rawIndexableTextContent":" ","title":"create(_:withInitialCommit:)","kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/FileRepository\/create(_:withInitialCommit:)"}},"headings":[]},{"kind":"symbol","summary":"","rawIndexableTextContent":" ","headings":[],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/init(from:)","interfaceLanguage":"swift"}},"title":"init(from:)"},{"kind":"symbol","rawIndexableTextContent":"Merges from one fork into the main fork. May perform a 3-way merge. A MergeAction is returned to indicate the type of merge that took place. After this operation, the main fork may be updated. The version of the other fork will be unchanged. Note that this may change the commits stored in unrelated forks, in order to preserve common ancestors. This particular overload handles merges of non-Mergeable resources. ","headings":[],"title":"mergeIntoMain(from:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mergeIntoMain(from:)-9wpr4","interfaceLanguage":"swift"}},"summary":"Merges from one fork into the main fork. May perform a 3-way merge. A MergeAction is returned to indicate the type of merge that took place. After this operation, the main fork may be updated. The version of the other fork will be unchanged. Note that this may change the commits stored in unrelated forks, in order to preserve common ancestors. This particular overload handles merges of non-Mergeable resources."},{"rawIndexableTextContent":"The resource is Equatable, so test explicitly for equality. ","summary":"The resource is Equatable, so test explicitly for equality.","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/CommitContent\/==(_:_:)","interfaceLanguage":"swift"}},"title":"==(_:_:)","headings":[],"kind":"symbol"},{"title":"delete(_:)","rawIndexableTextContent":" ","kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/delete(_:)"}},"headings":[],"summary":""},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/FileRepository\/delete(_:)","interfaceLanguage":"swift"}},"kind":"symbol","rawIndexableTextContent":" ","title":"delete(_:)","headings":[],"summary":""},{"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedInnards"}},"headings":["Centralized vs Decentralized","The Traditional Approach","The Decentralized Way","The Reality of Modern Apps","Sync Comes for Free","Forked and Actor-Based Systems","Architectural Components","The Forked Hub"],"kind":"article","title":"Forked Innards: Understanding the Architecture","summary":"Forked is built around a simple yet powerful concept: data conflicts should be treated as a natural part of software systems rather than an exceptional state.","rawIndexableTextContent":"Forked is built around a simple yet powerful concept: data conflicts should be treated as a natural part of software systems rather than an exceptional state. Centralized vs Decentralized The Traditional Approach Applications traditionally use a centralized approach to manage shared data. At the heart of this approach lies a central coordinator, such as a lock, queue, or actor, which protects the shared resource, providing serial access to it. While this pattern is familiar, it comes with significant drawbacks. Changes must be synchronized through the coordinator, forcing other parts of the system to wait while changes occur. This not only creates bottlenecks and synchronization costs but also makes it challenging to reason about the system’s state, often leading to subtle race conditions. The Decentralized Way Forked takes inspiration from proven distributed version control systems like Git. With these systems, changes flow more naturally. Developers can work independently, without waiting to coordinate with other developers. When conflicts arise, the system has a complete picture of what’s changed through its history tracking. This philosophy translates directly to how Forked operates in your application. You’re free to modify data without considering other subsystems or devices, and reconciliation happens later through well-defined merge policies. The key innovation is Forked’s support for 3-way merging, where a historical “common ancestor” helps determine exactly what’s changed in each fork when a conflict arises. The Reality of Modern Apps Most modern applications are inherently decentralized, whether intentional or not. Consider how your app might sync data across multiple devices, or how app extensions operate in separate processes on shared data. Even background processes performing imports or downloads from a web service must coordinate with the main app. These scenarios all represent decentralized operations, even if we often try to force them into a centralized model. Sync Comes for Free Forked’s decentralized approach means that sync is a natural part of the system. By providing some limited history tracking, in the form of a common ancestor, as well a powerful merging, you can begin developing an app for a single device, and very simply add support for sync with no model changes, and no custom server. Just connect iCloud, and you’re done. Forked and Actor-Based Systems While actors excel at preventing data races through controlled access to shared resources, they can’t prevent higher-level race conditions or solve the complexities of reentrant code and interleaved operations. This is where Forked steps up, complementing actor-based architectures by providing robust conflict management capabilities. Architectural Components The Forked Hub Rather than implementing a full version control system, Forked maintains just enough history for effective 3-way merging, keeping memory usage low. In optimal cases, the size of a ForkedResource is practically the same as the size of the resource it contains. In a ForkedResource, forks are arranged in a hub-and-spoke pattern. The hub is the main fork, while other forks (the spokes) can merge with the main fork, but not directly with each other.  The main fork in the hub stores exactly one copy of the resource — its current value. Other forks, on the other hand, are responsible for keeping track of the common ancestor when updates occur. In this way, a 3-way merge between the main fork and any other fork can be performed at any time. The non-main forks can contain various copies of the resource, based on their relationship to the main fork: When a fork is in sync with the main fork, it stores no additional copies of the resource When the main fork has progressed ahead, the fork retains only the common ancestor copy When the fork conflicts with the main fork, it maintains two copies: the common ancestor and its own most recent value Whenever an update to any fork is made, copies of the resource into forks can arise. For example, take the simple case that all forks are in sync. If an update occurs to the main fork, a copy of the resource is made into all of the non-main forks, because they all need a common ancestor to perform a 3-way merge in future. Later, if the main fork gets fully synced with one of the other forks, that fork will no longer have any copy of the resource. This careful management of state means that: The minimum necessary history is preserved in order to facilitate 3-way merges When all forks are in sync, only one copy of the resource exists in memory Memory usage scales with the number of conflicts, not with the number of forks The spoked architecture keeps the number of common ancestors low, because they aren’t needed for every single pair of forks"},{"headings":[],"rawIndexableTextContent":"Initialize with no persistence ","summary":"Initialize with no persistence","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/init()"}},"kind":"symbol","title":"init()"},{"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Repository\/Resource","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"Resource","headings":[],"rawIndexableTextContent":" ","kind":"symbol","summary":""},{"rawIndexableTextContent":"Returns a partial range up to, but not including, its upper bound.  The upper bound for the range. Discussion Use the prefix half-open range operator (prefix ..<) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeUpTo<Double> instance that includes any value less than 5.0.  You can use this type of partial range of a collection’s indices to represent the range from the start of the collection up to, but not including, the partial range’s upper bound.  maximum must compare equal to itself (i.e. cannot be NaN).","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Version\/.._(_:)"},"type":"topLevelPage"},"title":"..<(_:)","summary":"Returns a partial range up to, but not including, its upper bound.","headings":["Discussion"],"kind":"symbol"},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Fork\/Equatable-Implementations","interfaceLanguage":"swift"}},"summary":"","kind":"article","headings":[],"rawIndexableTextContent":"","title":"Equatable Implementations"},{"rawIndexableTextContent":" ","kind":"symbol","title":"salvaging(from:)","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Swift\/Optional\/salvaging(from:)"},"type":"topLevelPage"},"summary":"","headings":[]},{"kind":"symbol","summary":"","rawIndexableTextContent":" ","title":"ForkedResource.ResourceType","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/ResourceType","interfaceLanguage":"swift"}},"headings":[]},{"summary":"Merges other forks into main, and then main into the target fork, so it has up-to-date data from all other forks. You can pass in .main if you want to merge all other forks into .main. This particular overload handles merges of  Mergeable resources.","headings":[],"rawIndexableTextContent":"Merges other forks into main, and then main into the target fork, so it has up-to-date data from all other forks. You can pass in .main if you want to merge all other forks into .main. This particular overload handles merges of  Mergeable resources. ","kind":"symbol","title":"mergeAllForks(into:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mergeAllForks(into:)-3bh6r","interfaceLanguage":"swift"}}},{"kind":"article","title":"Equatable Implementations","summary":"","rawIndexableTextContent":"","headings":[],"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Version\/Equatable-Implementations"}}},{"kind":"symbol","summary":"Returns a partial range extending upward from a lower bound.","title":"...(_:)","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/...(_:)-3z0z5","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":["Discussion"],"rawIndexableTextContent":"Returns a partial range extending upward from a lower bound.  The lower bound for the range. Discussion Use the postfix range operator (postfix ...) to create a partial range of any type that conforms to the Comparable protocol. This example creates a PartialRangeFrom<Double> instance that includes any value greater than or equal to 5.0.  You can use this type of partial range of a collection’s indices to represent the range from the partial range’s lower bound up to the end of the collection.  minimum must compare equal to itself (i.e. cannot be NaN)."},{"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mostRecentCommit(of:)"}},"headings":[],"kind":"symbol","summary":"Returns the most recent (current) commit of the Fork.","title":"mostRecentCommit(of:)","rawIndexableTextContent":"Returns the most recent (current) commit of the Fork. "},{"title":"Identifiable Implementations","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Swift\/Optional\/Identifiable-Implementations","interfaceLanguage":"swift"}},"summary":"","kind":"article","rawIndexableTextContent":"","headings":[]},{"title":"versions(storedIn:)","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Repository\/versions(storedIn:)"}},"summary":"All versions stored in a given fork. There will usually be 0, 1 or 2, though there may be temporaily more. Note that this is just the versions stored for the fork. The interpretation of the stored versions is handled by the ForkedResource. For example, if there are no versions in the fork of the repo, the ForkedResource will assume it is at the same version as stored in the main fork.","kind":"symbol","headings":[],"rawIndexableTextContent":"All versions stored in a given fork. There will usually be 0, 1 or 2, though there may be temporaily more. Note that this is just the versions stored for the fork. The interpretation of the stored versions is handled by the ForkedResource. For example, if there are no versions in the fork of the repo, the ForkedResource will assume it is at the same version as stored in the main fork. "},{"headings":[],"rawIndexableTextContent":" ","title":"init(from:)","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/CommitContent\/init(from:)"},"type":"topLevelPage"},"kind":"symbol","summary":""},{"title":"MergeAction","kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/MergeAction"}},"summary":"The action taken when two forks are merged.","rawIndexableTextContent":"The action taken when two forks are merged. ","headings":[]},{"summary":"","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Commit\/hash(into:)"}},"kind":"symbol","headings":[],"title":"hash(into:)","rawIndexableTextContent":" "},{"location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/FileRepository"},"type":"topLevelPage"},"summary":"A FileRepository stores its contents in a directory structure on disk. Each fork corresponds to a subdirectory, and files are stored within those subdirectories.","rawIndexableTextContent":"A FileRepository stores its contents in a directory structure on disk. Each fork corresponds to a subdirectory, and files are stored within those subdirectories. ","headings":[],"title":"FileRepository","kind":"symbol"},{"title":"persist()","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/persist()-91lo2","interfaceLanguage":"swift"}},"kind":"symbol","summary":"","headings":[],"rawIndexableTextContent":" "},{"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/_=(_:_:)-8ckx5","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":["Discussion"],"kind":"symbol","rawIndexableTextContent":"Returns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument.  A value to compare. Another value to compare. Discussion This is the default implementation of the less-than-or-equal-to operator (<=) for any type that conforms to Comparable.","title":"<=(_:_:)","summary":"Returns a Boolean value indicating whether the value of the first argument is less than or equal to that of the second argument."},{"summary":"All forks in the resource, including the main fork, in no particular order","kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/forks","interfaceLanguage":"swift"}},"title":"forks","headings":[],"rawIndexableTextContent":"All forks in the resource, including the main fork, in no particular order "},{"title":"Error.attemptToReplaceExistingVersion(_:_:)","headings":[],"rawIndexableTextContent":" ","kind":"symbol","summary":"","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Error\/attemptToReplaceExistingVersion(_:_:)"},"type":"topLevelPage"}},{"title":"fork","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkChange\/fork","interfaceLanguage":"swift"}},"kind":"symbol","summary":"","rawIndexableTextContent":" ","headings":[]},{"title":"count","summary":"","headings":[],"rawIndexableTextContent":" ","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/count","interfaceLanguage":"swift"}},"kind":"symbol"},{"rawIndexableTextContent":" ","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Error\/unexpectedError(_:)"},"type":"topLevelPage"},"kind":"symbol","headings":[],"title":"Error.unexpectedError(_:)","summary":""},{"kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Fork\/isProtected","interfaceLanguage":"swift"},"type":"topLevelPage"},"summary":"Whether the fork is protected from deletion. Only the main fork has this protection for now.","headings":[],"rawIndexableTextContent":"Whether the fork is protected from deletion. Only the main fork has this protection for now. ","title":"isProtected"},{"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Commit","interfaceLanguage":"swift"},"type":"topLevelPage"},"summary":"A commit comprises of content, which is usually a value of the stored resource, together with a Version.","kind":"symbol","headings":[],"rawIndexableTextContent":"A commit comprises of content, which is usually a value of the stored resource, together with a Version. ","title":"Commit"},{"title":"salvaging(from:)","headings":[],"kind":"symbol","rawIndexableTextContent":" ","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Mergeable\/salvaging(from:)-3p5f"}},"summary":""},{"headings":[],"summary":"Loads repo from storage if this is a persistable repo. Do not call this unless you are using a type that is persistable, otherwise you will get a fatalError.","kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Persistent\/load()","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"load()","rawIndexableTextContent":"Loads repo from storage if this is a persistable repo. Do not call this unless you are using a type that is persistable, otherwise you will get a fatalError. "},{"title":"!=(_:_:)","kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/CommitContent\/!=(_:_:)","interfaceLanguage":"swift"}},"headings":["Discussion"],"rawIndexableTextContent":"Returns a Boolean value indicating whether two values are not equal.  A value to compare. Another value to compare. Discussion Inequality is the inverse of equality. For any values a and b, a != b implies that a == b is false. This is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.","summary":"Returns a Boolean value indicating whether two values are not equal."},{"headings":[],"title":"id","kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Swift\/Optional\/id"}},"summary":"","rawIndexableTextContent":" "},{"kind":"symbol","headings":[],"summary":"","title":"store(_:in:)","rawIndexableTextContent":" ","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/FileRepository\/store(_:in:)"}}},{"kind":"symbol","headings":[],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Repository\/forks","interfaceLanguage":"swift"}},"title":"forks","summary":"The forks in the repository, including .main, in no particular order.","rawIndexableTextContent":"The forks in the repository, including .main, in no particular order. "},{"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/VersionedModel\/currentModelVersion"}},"rawIndexableTextContent":"The current version of the model for this resource (struct). It is generally best to start the current version at 0, and increase it by one whenever a change is made to the properties of a struct. If you have not being using VersionedModel, and add sync, you would use 0 if your model is unchanged, and 1 if it changed from the un-synced version. The old un-synced model will get a modelVersion of nil, which is treated as 0. Using 1 will cause Forked to avoid merging the newer model into the old one. ","kind":"symbol","title":"currentModelVersion","summary":"The current version of the model for this resource (struct). It is generally best to start the current version at 0, and increase it by one whenever a change is made to the properties of a struct. If you have not being using VersionedModel, and add sync, you would use 0 if your model is unchanged, and 1 if it changed from the un-synced version. The old un-synced model will get a modelVersion of nil, which is treated as 0. Using 1 will cause Forked to avoid merging the newer model into the old one.","headings":[]},{"summary":"A wrapper to hold the resource. This allows for the resource to be absent in a fork, similar to using nil.","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/CommitContent"},"type":"topLevelPage"},"headings":[],"title":"CommitContent","kind":"symbol","rawIndexableTextContent":"A wrapper to hold the resource. This allows for the resource to be absent in a fork, similar to using nil. "},{"rawIndexableTextContent":" ","kind":"symbol","title":"content(of:at:)","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/FileRepository\/content(of:at:)"}},"summary":"","headings":[]},{"title":"VersionedModel","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/VersionedModel","interfaceLanguage":"swift"}},"summary":"Protocol to track the model version of a ForkedResource. This isn’t very important on a single device, but if syncing between devices, it is important that a device that doesn’t yet have the latest version does not try to import data from that version. If it does, it won’t know how to handle it, and may lose data.","rawIndexableTextContent":"Protocol to track the model version of a ForkedResource. This isn’t very important on a single device, but if syncing between devices, it is important that a device that doesn’t yet have the latest version does not try to import data from that version. If it does, it won’t know how to handle it, and may lose data. ","headings":[],"kind":"symbol"},{"kind":"symbol","headings":[],"title":"version","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Commit\/version","interfaceLanguage":"swift"}},"rawIndexableTextContent":"The version when the copy of the resource was committed. ","summary":"The version when the copy of the resource was committed."},{"rawIndexableTextContent":"Convenience for creating simple forked resource for in-memory use. Create an in-memory ForkedResource with the given forks, and initial value. The initial value is optional. If not provided, the main fork will be empty. The setup ensures that all forks are synced up with the initial value, which is different to the default behavior when you first create a ForkedResource. (In a forked resource, a new fork is initially empty, and may not be in sync with the main fork until merged.) ","headings":[],"kind":"symbol","summary":"Convenience for creating simple forked resource for in-memory use. Create an in-memory ForkedResource with the given forks, and initial value. The initial value is optional. If not provided, the main fork will be empty. The setup ensures that all forks are synced up with the initial value, which is different to the default behavior when you first create a ForkedResource. (In a forked resource, a new fork is initially empty, and may not be in sync with the main fork until merged.)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/init(initialValue:forks:)","interfaceLanguage":"swift"}},"title":"init(initialValue:forks:)"},{"kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/content(of:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"rawIndexableTextContent":"Returns the current content of the fork ","title":"content(of:)","headings":[],"summary":"Returns the current content of the fork"},{"kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mergeFromMain(into:)-5tynb","interfaceLanguage":"swift"}},"headings":[],"title":"mergeFromMain(into:)","summary":"Merges from the main fork into another fork. May perform a 3-way merge. A MergeAction is returned to indicate the type of merge that took place. After this operation, the fork may be updated, with the version of the main fork unchanged. This particular overload handles merges of non-Mergeable resources.","rawIndexableTextContent":"Merges from the main fork into another fork. May perform a 3-way merge. A MergeAction is returned to indicate the type of merge that took place. After this operation, the fork may be updated, with the version of the main fork unchanged. This particular overload handles merges of non-Mergeable resources. "},{"summary":"","headings":[],"title":"load()","rawIndexableTextContent":" ","kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/load()-520e","interfaceLanguage":"swift"},"type":"topLevelPage"}},{"kind":"symbol","summary":"Returns the most recent (current) version of the Fork.","headings":[],"rawIndexableTextContent":"Returns the most recent (current) version of the Fork. ","title":"mostRecentVersion(of:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mostRecentVersion(of:)","interfaceLanguage":"swift"}}},{"rawIndexableTextContent":"The version of the Forked API. Older versions are incapable or understanding or merging with the newer versions. (Newer versions should be capable of importing the older ones.) ","summary":"The version of the Forked API. Older versions are incapable or understanding or merging with the newer versions. (Newer versions should be capable of importing the older ones.)","title":"forkedAPIVersion","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/forkedAPIVersion"},"type":"topLevelPage"},"headings":[],"kind":"symbol"},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/Comparable-Implementations","interfaceLanguage":"swift"}},"kind":"article","rawIndexableTextContent":"","summary":"","title":"Comparable Implementations","headings":[]},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/MergeAction\/resolveConflict","interfaceLanguage":"swift"}},"summary":"The two forks had both changed since the common ancestor version. They were merged to produce a new value for the destination fork.","headings":[],"kind":"symbol","rawIndexableTextContent":"The two forks had both changed since the common ancestor version. They were merged to produce a new value for the destination fork. ","title":"MergeAction.resolveConflict"},{"headings":[],"summary":"","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/removeCommit(at:from:)","interfaceLanguage":"swift"}},"kind":"symbol","title":"removeCommit(at:from:)","rawIndexableTextContent":" "},{"summary":"","kind":"article","headings":[],"rawIndexableTextContent":"","title":"Decodable Implementations","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Commit\/Decodable-Implementations"},"type":"topLevelPage"}},{"kind":"symbol","platforms":[{"beta":false,"deprecated":false,"unavailable":false,"name":"iOS","introducedAt":"8.0"},{"name":"macOS","introducedAt":"10.10","deprecated":false,"unavailable":false,"beta":false},{"beta":false,"name":"tvOS","introducedAt":"9.0","deprecated":false,"unavailable":false},{"introducedAt":"2.0","name":"watchOS","unavailable":false,"beta":false,"deprecated":false}],"headings":[],"summary":"Retrieve the localized description for this error.","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Error\/localizedDescription"}},"rawIndexableTextContent":"Retrieve the localized description for this error. ","title":"localizedDescription"},{"kind":"symbol","summary":"","title":"Error.attemptToAccessNonExistentVersion(_:_:)","rawIndexableTextContent":" ","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Error\/attemptToAccessNonExistentVersion(_:_:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":[]},{"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Persistent\/persist()-7xbbi","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":[],"title":"persist()","rawIndexableTextContent":" ","summary":"","kind":"symbol"},{"summary":"Persist using Codable","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/init(managedFileURL:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"init(managedFileURL:)","headings":[],"rawIndexableTextContent":"Persist using Codable ","kind":"symbol"},{"kind":"symbol","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/content(of:at:)"},"type":"topLevelPage"},"summary":"","rawIndexableTextContent":" ","title":"content(of:at:)","headings":[]},{"kind":"symbol","rawIndexableTextContent":"A framework for handling shared data with confidence in Swift. Overview Forked provides a comprehensive solution for managing concurrent data access and synchronization through a Git-inspired branching and merging system. Instead of using traditional concurrency primitives like locks or actors, Forked allows you to safely work with multiple copies of data and merge them systematically. Key Concepts Forks A fork represents a branch of your data that can be modified independently of other branches. Every ForkedResource has a main fork, and you can create additional named forks for different purposes like UI updates, background processing, or network synchronization. Resources A ForkedResource manages the state and history of your data across multiple forks. It tracks changes, maintains the common ancestor states needed for merging, and provides methods for updating and querying values in different forks. Merging When forks diverge and need to be reconciled, Forked provides sophisticated merging capabilities. The framework supports both automatic merging for simple types and custom merge strategies for complex data structures. Repositories A ForkedResource does not actually store any data: it just contains the logic for managing forks and resources. Repositories provide the storage for a ForkedResource, whether it be in memory, on disk, in a database, or in the cloud.","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked","interfaceLanguage":"swift"}},"title":"Forked","headings":["Overview","Key Concepts","Forks","Resources","Merging","Repositories"],"summary":"A framework for handling shared data with confidence in Swift."},{"summary":"Whether a fork exists in the ForkedResource","rawIndexableTextContent":"Whether a fork exists in the ForkedResource ","headings":[],"kind":"symbol","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/has(_:)"},"type":"topLevelPage"},"title":"has(_:)"},{"summary":"","kind":"symbol","title":"version","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkChange\/version"}},"headings":[],"rawIndexableTextContent":" "},{"title":"Mergeable Implementations","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Swift\/Optional\/Mergeable-Implementations","interfaceLanguage":"swift"}},"kind":"article","summary":"","headings":[],"rawIndexableTextContent":""},{"kind":"symbol","title":"CommitContent.resource(_:)","summary":"The content contains a value of the resource.","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/CommitContent\/resource(_:)"}},"headings":[],"rawIndexableTextContent":"The content contains a value of the resource. "},{"title":"syncMain(with:)","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/syncMain(with:)-18a6t","interfaceLanguage":"swift"},"type":"topLevelPage"},"kind":"symbol","summary":"Brings main and the other fork to the same version by first merging from the other fork into main, and then merging from main into the other fork (fast forward). This particular overload handles merges of  Mergeable resources. To sync up all forks, just pass all forks to this func, including .main. The main fork is ignored when merging.","headings":[],"rawIndexableTextContent":"Brings main and the other fork to the same version by first merging from the other fork into main, and then merging from main into the other fork (fast forward). This particular overload handles merges of  Mergeable resources. To sync up all forks, just pass all forks to this func, including .main. The main fork is ignored when merging. "},{"title":"!=(_:_:)","headings":["Discussion"],"kind":"symbol","rawIndexableTextContent":"Returns a Boolean value indicating whether two values are not equal.  A value to compare. Another value to compare. Discussion Inequality is the inverse of equality. For any values a and b, a != b implies that a == b is false. This is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/!=(_:_:)","interfaceLanguage":"swift"}},"summary":"Returns a Boolean value indicating whether two values are not equal."},{"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Repository\/content(of:at:)"}},"kind":"symbol","summary":"Get the content from the repo with the version passed. If not found, it will throw an error.","title":"content(of:at:)","rawIndexableTextContent":"Get the content from the repo with the version passed. If not found, it will throw an error. ","headings":[]},{"kind":"symbol","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository"},"type":"topLevelPage"},"headings":[],"summary":"An atomic repository is one that gets loaded completely into memory. If the Resource it contains conforms to Codable, the AtomicRepository is also Codable, and can be converted to a serialized form and saved as a file. Saving and loading are atomic, that is, the whole repository is loaded from file, and the whole file is written to disk.","title":"AtomicRepository","rawIndexableTextContent":"An atomic repository is one that gets loaded completely into memory. If the Resource it contains conforms to Codable, the AtomicRepository is also Codable, and can be converted to a serialized form and saved as a file. Saving and loading are atomic, that is, the whole repository is loaded from file, and the whole file is written to disk. "},{"headings":[],"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mostRecentVersionOfMain()"}},"summary":"The most recent (current) version of the main fork.","rawIndexableTextContent":"The most recent (current) version of the main fork. ","title":"mostRecentVersionOfMain()","kind":"symbol"},{"summary":"Returns a Boolean value indicating whether two values are not equal.","rawIndexableTextContent":"Returns a Boolean value indicating whether two values are not equal.  A value to compare. Another value to compare. Discussion Inequality is the inverse of equality. For any values a and b, a != b implies that a == b is false. This is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.","title":"!=(_:_:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkChange\/!=(_:_:)","interfaceLanguage":"swift"}},"headings":["Discussion"],"kind":"symbol"},{"title":"mergeFromMain(into:)","headings":[],"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mergeFromMain(into:)-6o9f","interfaceLanguage":"swift"},"type":"topLevelPage"},"summary":"Merges from the main fork into another fork. May perform a 3-way merge. A MergeAction is returned to indicate the type of merge that took place. After this operation, the fork may be updated, with the version of the main fork unchanged. This particular overload handles merges of Mergeable resources.","kind":"symbol","rawIndexableTextContent":"Merges from the main fork into another fork. May perform a 3-way merge. A MergeAction is returned to indicate the type of merge that took place. After this operation, the fork may be updated, with the version of the main fork unchanged. This particular overload handles merges of Mergeable resources. "},{"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":[],"kind":"symbol","rawIndexableTextContent":"Used to chronologically order file versions. It is a standard lamport count. ","title":"Version","summary":"Used to chronologically order file versions. It is a standard lamport count."},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/restart(_:with:)","interfaceLanguage":"swift"}},"summary":"Update the contents of a fork with a new resource value. Will create a commit, and return the Version. The difference between a restart and an update, is that the resource passed is assumed to be the common ancestor of the fork with .main. Sometimes you can’t achieve something through merging, and this gives an override. In general, it should not be needed much, but is handy when in some instances. Only use this if you know that the value of the resource precedes the value in .main, such that it is eligble to be a common ancestor. If the value in .main is actually older, doing this will undo any changes in .main. You can’t restart the .main fork.","rawIndexableTextContent":"Update the contents of a fork with a new resource value. Will create a commit, and return the Version. The difference between a restart and an update, is that the resource passed is assumed to be the common ancestor of the fork with .main. Sometimes you can’t achieve something through merging, and this gives an override. In general, it should not be needed much, but is handy when in some instances. Only use this if you know that the value of the resource precedes the value in .main, such that it is eligble to be a common ancestor. If the value in .main is actually older, doing this will undo any changes in .main. You can’t restart the .main fork. ","headings":[],"kind":"symbol","title":"restart(_:with:)"},{"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Swift\/Optional\/merged(withSubordinate:commonAncestor:)","interfaceLanguage":"swift"}},"kind":"symbol","title":"merged(withSubordinate:commonAncestor:)","summary":"","headings":[],"rawIndexableTextContent":" "},{"kind":"symbol","title":"removeContent(from:)","summary":"Adds a new commit with content .none. This is like setting the content to nil. Note that this does not remove the fork, and the fork does still have commits. However, the value of the most recent commit will be .none, to indicate the absence of a resource. (This construction is sometimes referred to as a “tombstone”. It is a commit that indicates that something has been removed.)","rawIndexableTextContent":"Adds a new commit with content .none. This is like setting the content to nil. Note that this does not remove the fork, and the fork does still have commits. However, the value of the most recent commit will be .none, to indicate the absence of a resource. (This construction is sometimes referred to as a “tombstone”. It is a commit that indicates that something has been removed.) ","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/removeContent(from:)"}},"headings":[]},{"rawIndexableTextContent":"Any type conforming to this can be used in a 3-way merge ","summary":"Any type conforming to this can be used in a 3-way merge","kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Mergeable","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"Mergeable","headings":[]},{"title":"QuickFork","rawIndexableTextContent":" ","summary":"","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/QuickFork","interfaceLanguage":"swift"}},"kind":"symbol","headings":[]},{"summary":"","headings":[],"rawIndexableTextContent":" ","title":"persist()","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/persist()"}},"kind":"symbol"},{"kind":"article","headings":["Overview","Getting Started","Basic Setup","How It Works","Model Versioning","Example Implementation","CloudKit Setup in Xcode","Advanced Usage","Custom Container","Monitoring Sync Updates","CloudKit Schema Setup","Managing File Assets with CloudKitAssets","Basic Usage","Monitoring Changes","File Size Limits","Troubleshooting","Further Reading"],"rawIndexableTextContent":"Learn how to use ForkedCloudKit to sync your data across devices. Overview ForkedCloudKit makes it easy to sync your Forked data between devices using Apple’s CloudKit framework. This guide will walk you through the basic setup and usage. Getting Started First, make sure you have the ForkedCloudKit subpackage added to your project dependencies. Then import ForkedCloudKit in your source files:  Basic Setup The main class you’ll work with is CloudKitExchange. Here’s how to set it up:  The id parameter should be a unique string that identifies this resource in CloudKit. How It Works CloudKitExchange automatically: Monitors changes to your ForkedResource’s main fork Uploads changes to iCloud when detected Downloads changes from other devices Before merging any changes, it checks the model version of the remote data and the local data. If the model version from iCloud is one that is unknown in the local app, it calls the unknownModelVersionHandler closure, and stops syncing. The user should update their app to the latest version. If the model is known, it merges the remote changes into your local data on the main fork All of this happens in the background without blocking your app’s UI. Model Versioning ForkedCloudKit requires your model to conform to VersionedModel to ensure safe syncing across different app versions. This is crucial because: Different versions of your app may have different data models When syncing, you need to ensure the app can understand the data it receives Older versions of your app should not try to merge data from newer, unknown model versions Here’s how to make your model versioned:  When you update your model in a new app version, increment the version by 1. If CloudKitExchange encounters data with an unknown version (higher than the version in the code): It calls your unknownModelVersionHandler closure Stops syncing to prevent data corruption The user should be prompted to update their app Example Implementation Here’s a complete example showing how to integrate CloudKit sync into a SwiftUI app:  CloudKit Setup in Xcode Before your app can use CloudKit: Enable iCloud in your Xcode target’s capabilities tab Choose or add a container (eg “iCloud.com.mycompany.myapp”). The container ID should match the id parameter in your CloudKitExchange initializer. Also enable the background modes for remote notifications and background processing Advanced Usage Custom Container By default, CloudKitExchange uses the default CloudKit container. You can specify a custom container:  Monitoring Sync Updates CloudKitExchange automatically handles sync in the background, but you can monitor when changes from CloudKit are merged into your main fork. To do this, add a Task on launch that monitors the changeStream for changes from CloudKit:  CloudKit Schema Setup Before your app can use CloudKit, you need to set up the schema. You could do this by running your app in development mode in Xcode, but if you do this, you are unlikely to trigger certain situations, such as when you have a very large file. For this reason, it is best to actively import the CloudKit schema used by Forked. Enable iCloud in your Xcode target’s capabilities tab Choose or add a container (eg “iCloud.com.mycompany.myapp”) Import the CloudKit schema file (cloudkit-schema.ckdb) into your development environment using the CloudKit Console (https:\/\/icloud.developer.apple.com) Deploy the schema to production before releasing your app The schema defines two Forked-related record types:  Important: You must deploy the schema to production before releasing your app. If you don’t, users won’t be able to sync their data. Managing File Assets with CloudKitAssets The CloudKitAssets class provides a simple way to manage file assets with CloudKit synchronization. It automatically handles: Storing files in CloudKit Syncing files across devices Splitting large files into parts (up to 250MB total) Soft deletion of files Basic Usage  Monitoring Changes You can monitor changes to assets using the changeStream property:  File Size Limits Individual files must be under 250MB Files over 50MB are automatically split into parts (up to 5 parts) The total size of all parts must not exceed 250MB Troubleshooting Common issues and solutions: No Sync: Ensure iCloud is enabled on the device, the user is signed in, and iCloud Drive enabled Data Not Appearing: Check that your CloudKit container is properly configured. No Sync in Production Version: Make sure you push your CloudKit schema to production before launching your app. Use the CloudKit web portal (https:\/\/icloud.developer.apple.com) to do this Conflicts: ForkedCloudKit automatically handles conflicts using your resource’s merge strategy Further Reading CloudKit Documentation Forked Documentation Sample App: Forking Simple iCloud","title":"CloudKit Integration Guide","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/CloudKitIntegration","interfaceLanguage":"swift"}},"summary":"Learn how to use ForkedCloudKit to sync your data across devices."},{"kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkChange\/mergingFork"}},"summary":"","rawIndexableTextContent":" ","headings":[],"title":"mergingFork"},{"summary":"","kind":"symbol","title":"store(_:in:)","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/store(_:in:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"rawIndexableTextContent":" ","headings":[]},{"rawIndexableTextContent":"Removes all content from all branches, resetting to the initial state. It does not remove the existing branches, but removes their content. ","title":"removeAllContent()","kind":"symbol","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/removeAllContent()"},"type":"topLevelPage"},"summary":"Removes all content from all branches, resetting to the initial state. It does not remove the existing branches, but removes their content.","headings":[]},{"rawIndexableTextContent":"The version of the Forked API used to create this resource. ","title":"forkedVersion","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/forkedVersion"}},"headings":[],"summary":"The version of the Forked API used to create this resource.","kind":"symbol"},{"summary":"Create a new fork. Will throw if a fork with the same name already exists.","title":"create(_:)","headings":[],"rawIndexableTextContent":"Create a new fork. Will throw if a fork with the same name already exists. ","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/create(_:)"}},"kind":"symbol"},{"title":"Getting Started with Forked","summary":"Learn how to use Forked to manage shared data in your Swift applications.","headings":["Overview","Creating Your First Resource","Working with Forks","Creating Named Forks","Updating Values","Merging Changes","Merging Direction","Working with Complex Types","Next Steps"],"rawIndexableTextContent":"Learn how to use Forked to manage shared data in your Swift applications. Overview Forked provides a safe way to handle shared data by allowing you to create independent branches (forks) of your data that can be modified concurrently and merged later. This guide will walk you through the basic concepts using practical examples. Creating Your First Resource The easiest way to get started is with QuickFork, which manages a single value in memory:  value(in:) returns an optional because the value might not exist in a given fork. When you’re sure the value exists (like right after creation), you can force unwrap with !. In production code, you might want to handle the optional more safely. Working with Forks Creating Named Forks While every resource has a .main fork, you’ll often want to create additional named forks. One convenient approach is to define your forks as static properties in an extension to Fork:  You can also create forks directly if you prefer:  Updating Values You can update values independently in different forks:  Merging Changes When you’re ready to reconcile changes between forks, you can merge them. All merges must go through the main fork - you cannot merge directly between custom forks:  Merging Direction Merging is directional - changes flow from the source fork to the destination fork. To fully synchronize two forks, you need to merge in both directions:  For convenience, there’s a syncMain(with:) method that performs bidirectional merges between main and multiple forks:  Remember that syncing between custom forks still requires going through main. The sync method makes this easier by handling all the necessary merges in each direction. Working with Complex Types While the examples above use simple Int values, Forked really shines when working with complex types. Here’s an example using a custom type:  Next Steps Learn about different merging strategies in doc:MergingStrategy Explore automatic model generation with ForkedModel Add CloudKit sync with ForkedCloudKit","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/GettingStarted"}},"kind":"article"},{"headings":[],"rawIndexableTextContent":"Merges all forks so they are all at the same version. This involves merging all forks into the main fork first, and then merging the main fork into all other forks. This particular overload handles merges of  Mergeable resources. ","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/syncAllForks()-9xz2c"}},"kind":"symbol","title":"syncAllForks()","summary":"Merges all forks so they are all at the same version. This involves merging all forks into the main fork first, and then merging the main fork into all other forks. This particular overload handles merges of  Mergeable resources."},{"title":"ChangeStream","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ChangeStream"}},"summary":"","headings":[],"rawIndexableTextContent":" ","kind":"symbol"},{"kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/changeStream"}},"rawIndexableTextContent":"Creates and returns an AsyncStream which provides notifications of all changes to any fork in the repository. The stream will continue until cancelled or until the ForkedResource is deallocated. ","summary":"Creates and returns an AsyncStream which provides notifications of all changes to any fork in the repository. The stream will continue until cancelled or until the ForkedResource is deallocated.","title":"changeStream","headings":[]},{"headings":[],"summary":"When an object is created for the first time, or saved, this version is set to the most recent version (currentModelVersion). When loading data from disk (eg with Codable) or over a network, this can be compared with currentModelVersion to see if the model saved is a known version. If not, we should not try to merge with it. This is optional so that it is possible to add it to an existing model that was not versioned, and still use Codable migration. A value of nil is treated the same as 0.","kind":"symbol","title":"modelVersion","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/VersionedModel\/modelVersion","interfaceLanguage":"swift"},"type":"topLevelPage"},"rawIndexableTextContent":"When an object is created for the first time, or saved, this version is set to the most recent version (currentModelVersion). When loading data from disk (eg with Codable) or over a network, this can be compared with currentModelVersion to see if the model saved is a known version. If not, we should not try to merge with it. This is optional so that it is possible to add it to an existing model that was not versioned, and still use Codable migration. A value of nil is treated the same as 0. "},{"kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkChange","interfaceLanguage":"swift"}},"summary":"","rawIndexableTextContent":" ","headings":[],"title":"ForkChange"},{"rawIndexableTextContent":"Convenience for creating simple forked resource for in-memory use. Create an in-memory ForkedResource with the given fork names, and initial value. The setup ensures that all forks are synced up with the initial value — if there is one — which is different to the default behavior when you first create a ForkedResource. (In a forked resource, a new fork is initially empty, and may not be in sync with the main fork until merged.) ","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/init(initialValue:forkNames:)"},"type":"topLevelPage"},"kind":"symbol","title":"init(initialValue:forkNames:)","summary":"Convenience for creating simple forked resource for in-memory use. Create an in-memory ForkedResource with the given fork names, and initial value. The setup ensures that all forks are synced up with the initial value — if there is one — which is different to the default behavior when you first create a ForkedResource. (In a forked resource, a new fork is initially empty, and may not be in sync with the main fork until merged.)","headings":[]},{"headings":[],"title":"commonAncestor(of:)","summary":"Returns the common ancestor commit for a given fork with the main fork.","rawIndexableTextContent":"Returns the common ancestor commit for a given fork with the main fork. ","kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/commonAncestor(of:)"}}},{"summary":"The repository used to store data for the forked resource. The forked resource takes complete ownership of this. You should not use the repository from outside the ForkedResource object. Doing so may lead to threading errors or logic bugs.","headings":[],"title":"repository","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/repository"}},"kind":"symbol","rawIndexableTextContent":"The repository used to store data for the forked resource. The forked resource takes complete ownership of this. You should not use the repository from outside the ForkedResource object. Doing so may lead to threading errors or logic bugs. "},{"kind":"symbol","rawIndexableTextContent":"Same as calling resource(of:). ","summary":"Same as calling resource(of:).","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/value(in:)","interfaceLanguage":"swift"}},"headings":[],"title":"value(in:)"},{"rawIndexableTextContent":" ","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Fork\/init(from:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"summary":"","title":"init(from:)","kind":"symbol","headings":[]},{"headings":[],"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Commit\/Equatable-Implementations","interfaceLanguage":"swift"},"type":"topLevelPage"},"summary":"","title":"Equatable Implementations","kind":"article","rawIndexableTextContent":""},{"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/resource(of:)"}},"rawIndexableTextContent":"Will return the resource, if there is one available, and nil otherwise. ","summary":"Will return the resource, if there is one available, and nil otherwise.","title":"resource(of:)","headings":[],"kind":"symbol"},{"headings":[],"kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Error","interfaceLanguage":"swift"},"type":"topLevelPage"},"summary":"Errors that can arise when  using ForkedResource","title":"Error","rawIndexableTextContent":"Errors that can arise when  using ForkedResource "},{"headings":[],"rawIndexableTextContent":"Store a version of the resource in a fork. The fork must exist, and the version must not already be in the fork, otherwise an error is thrown. ","kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Repository\/store(_:in:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"store(_:in:)","summary":"Store a version of the resource in a fork. The fork must exist, and the version must not already be in the fork, otherwise an error is thrown."},{"location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Error\/attemptToAccessNonExistentFork(_:)"},"type":"topLevelPage"},"summary":"","rawIndexableTextContent":" ","kind":"symbol","title":"Error.attemptToAccessNonExistentFork(_:)","headings":[]},{"location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mainVersion(differsFromVersionIn:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":[],"kind":"symbol","title":"mainVersion(differsFromVersionIn:)","rawIndexableTextContent":"Whether the fork and main fork are at the same version or not. ","summary":"Whether the fork and main fork are at the same version or not."},{"summary":"Initialize the FileRepository with a root directory. Creates the directory if it doesn’t exist.","title":"init(rootDirectory:)","kind":"symbol","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/FileRepository\/init(rootDirectory:)","interfaceLanguage":"swift"}},"headings":[],"rawIndexableTextContent":"Initialize the FileRepository with a root directory. Creates the directory if it doesn’t exist. "},{"title":"timestamp","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/timestamp","interfaceLanguage":"swift"}},"headings":[],"summary":"","rawIndexableTextContent":" ","kind":"symbol"},{"title":"..<(_:_:)","headings":["Discussion"],"summary":"Returns a half-open range that contains its lower bound but not its upper bound.","rawIndexableTextContent":"Returns a half-open range that contains its lower bound but not its upper bound.  The lower bound for the range. The upper bound for the range. Discussion Use the half-open range operator (..<) to create a range of any type that conforms to the Comparable protocol. This example creates a Range<Double> from zero up to, but not including, 5.0.  minimum <= maximum.","kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/.._(_:_:)","interfaceLanguage":"swift"},"type":"topLevelPage"}},{"headings":[],"summary":"","rawIndexableTextContent":"","kind":"article","title":"Persistent Implementations","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/AtomicRepository\/Persistent-Implementations","interfaceLanguage":"swift"},"type":"topLevelPage"}},{"title":"Swift","rawIndexableTextContent":"","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Swift","interfaceLanguage":"swift"},"type":"topLevelPage"},"kind":"symbol","summary":"","headings":[]},{"summary":"","title":"forks","headings":[],"rawIndexableTextContent":" ","kind":"symbol","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/FileRepository\/forks"}}},{"location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/mergeIntoMain(from:)-352k5"},"type":"topLevelPage"},"kind":"symbol","rawIndexableTextContent":"Merges from one fork into the main fork. May perform a 3-way merge. A MergeAction is returned to indicate the type of merge that took place. After this operation, the main fork may be updated. The version of the other fork will be unchanged. Note that this may change the commits stored in unrelated forks, in order to preserve common ancestors. This particular overload handles merges of Mergeable resources. ","summary":"Merges from one fork into the main fork. May perform a 3-way merge. A MergeAction is returned to indicate the type of merge that took place. After this operation, the main fork may be updated. The version of the other fork will be unchanged. Note that this may change the commits stored in unrelated forks, in order to preserve common ancestors. This particular overload handles merges of Mergeable resources.","title":"mergeIntoMain(from:)","headings":[]},{"summary":"The content stored in the commit, usually a copy of the resource.","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/Commit\/content"}},"headings":[],"kind":"symbol","title":"content","rawIndexableTextContent":"The content stored in the commit, usually a copy of the resource. "},{"title":"Equatable Implementations","headings":[],"summary":"","location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/CommitContent\/Equatable-Implementations"}},"rawIndexableTextContent":"","kind":"article"},{"headings":[],"rawIndexableTextContent":" ","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Commit\/init(from:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"kind":"symbol","summary":"","title":"init(from:)"},{"headings":[],"rawIndexableTextContent":" ","kind":"symbol","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Version\/hash(into:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"title":"hash(into:)","summary":""},{"kind":"symbol","headings":[],"title":"hasUnmergedCommitsForMain(in:)","rawIndexableTextContent":"Whether fork has commits not yet merged into main. ","summary":"Whether fork has commits not yet merged into main.","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/ForkedResource\/hasUnmergedCommitsForMain(in:)","interfaceLanguage":"swift"},"type":"topLevelPage"}},{"title":"removeCommit(at:from:)","summary":"Remove a commit for a given version from the fork. If the version is not found, an error is thrown.","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Repository\/removeCommit(at:from:)","interfaceLanguage":"swift"}},"headings":[],"rawIndexableTextContent":"Remove a commit for a given version from the fork. If the version is not found, an error is thrown. ","kind":"symbol"},{"summary":"Returns a Boolean value indicating whether two values are not equal.","rawIndexableTextContent":"Returns a Boolean value indicating whether two values are not equal.  A value to compare. Another value to compare. Discussion Inequality is the inverse of equality. For any values a and b, a != b implies that a == b is false. This is the default implementation of the not-equal-to operator (!=) for any type that conforms to Equatable.","title":"!=(_:_:)","location":{"reference":{"url":"doc:\/\/Forked\/documentation\/Forked\/Fork\/!=(_:_:)","interfaceLanguage":"swift"},"type":"topLevelPage"},"headings":["Discussion"],"kind":"symbol"}]