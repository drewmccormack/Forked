{"metadata":{"role":"article","roleHeading":"Article","modules":[{"name":"Forked"}],"title":"Forked Innards: Understanding the Architecture"},"kind":"article","abstract":[{"text":"Forked is built around a simple yet powerful concept: data conflicts should be treated as a natural part of software systems rather than an exceptional state.","type":"text"}],"schemaVersion":{"patch":0,"minor":3,"major":0},"seeAlsoSections":[{"anchor":"Articles","title":"Articles","generated":true,"identifiers":["doc:\/\/Forked\/documentation\/Forked\/GettingStarted","doc:\/\/Forked\/documentation\/Forked\/CloudKitIntegration"]}],"primaryContentSections":[{"content":[{"level":2,"type":"heading","text":"Centralized vs Decentralized","anchor":"Centralized-vs-Decentralized"},{"text":"The Traditional Approach","anchor":"The-Traditional-Approach","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"Applications traditionally use a centralized approach to manage shared data. At the heart of this approach lies a central coordinator, such as a lock, queue, or actor, which protects the shared resource, providing serial access to it."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"While this pattern is familiar, it comes with significant drawbacks. Changes must be synchronized through the coordinator, forcing other parts of the system to wait while changes occur. This not only creates bottlenecks and synchronization costs but also makes it challenging to reason about the system’s state, often leading to subtle race conditions.","type":"text"}]},{"anchor":"The-Decentralized-Way","level":3,"type":"heading","text":"The Decentralized Way"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Forked takes inspiration from proven distributed version control systems like Git. With these systems, changes flow more naturally. Developers can work independently, without waiting to coordinate with other developers. When conflicts arise, the system has a complete picture of what’s changed through its history tracking."}]},{"inlineContent":[{"type":"text","text":"This philosophy translates directly to how Forked operates in your application. You’re free to modify data without considering other subsystems or devices, and reconciliation happens later through well-defined merge policies. The key innovation is Forked’s support for 3-way merging, where a historical “common ancestor” helps determine exactly what’s changed in each fork when a conflict arises."}],"type":"paragraph"},{"level":3,"anchor":"The-Reality-of-Modern-Apps","text":"The Reality of Modern Apps","type":"heading"},{"inlineContent":[{"text":"Most modern applications are inherently decentralized, whether intentional or not. Consider how your app might sync data across multiple devices, or how app extensions operate in separate processes on shared data. Even background processes performing imports or downloads from a web service must coordinate with the main app. These scenarios all represent decentralized operations, even if we often try to force them into a centralized model.","type":"text"}],"type":"paragraph"},{"type":"heading","level":3,"text":"Sync Comes for Free","anchor":"Sync-Comes-for-Free"},{"inlineContent":[{"type":"text","text":"Forked’s decentralized approach means that sync is a natural part of the system. By providing some limited history tracking, in the form of a common ancestor, as well a powerful merging, you can begin developing an app for a single device, and very simply add support for sync with no model changes, and no custom server. Just connect iCloud, and you’re done."}],"type":"paragraph"},{"text":"Forked and Actor-Based Systems","level":2,"type":"heading","anchor":"Forked-and-Actor-Based-Systems"},{"type":"paragraph","inlineContent":[{"text":"While actors excel at preventing data races through controlled access to shared resources, they can’t prevent higher-level race conditions or solve the complexities of reentrant code and interleaved operations. This is where Forked steps up, complementing actor-based architectures by providing robust conflict management capabilities.","type":"text"}]},{"text":"Architectural Components","level":2,"type":"heading","anchor":"Architectural-Components"},{"anchor":"The-Forked-Hub","level":3,"text":"The Forked Hub","type":"heading"},{"inlineContent":[{"type":"text","text":"Rather than implementing a full version control system, Forked maintains just enough history for effective 3-way merging, keeping memory usage low. In optimal cases, the size of a "},{"code":"ForkedResource","type":"codeVoice"},{"text":" is practically the same as the size of the resource it contains.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In a "},{"type":"codeVoice","code":"ForkedResource"},{"text":", forks are arranged in a hub-and-spoke pattern. The hub is the main fork, while other forks (the spokes) can merge with the main fork, but not directly with each other.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"ForkedHub"}]},{"inlineContent":[{"type":"text","text":"The main fork in the hub stores exactly one copy of the resource — its current value. Other forks, on the other hand, are responsible for keeping track of the common ancestor when updates occur. In this way, a 3-way merge between the main fork and any other fork can be performed at any time."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The non-main forks can contain various copies of the resource, based on their relationship to the main fork:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"When a fork is in sync with the main fork, it stores no additional copies of the resource"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When the main fork has progressed ahead, the fork retains only the common ancestor copy"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When the fork conflicts with the main fork, it maintains two copies: the common ancestor and its own most recent value"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"Whenever an update to any fork is made, copies of the resource into forks can arise. For example, take the simple case that all forks are in sync. If an update occurs to the main fork, a copy of the resource is made into all of the non-main forks, because they all need a common ancestor to perform a 3-way merge in future. Later, if the main fork gets fully synced with one of the other forks, that fork will no longer have any copy of the resource.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This careful management of state means that:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The minimum necessary history is preserved in order to facilitate 3-way merges","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"When all forks are in sync, only one copy of the resource exists in memory","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Memory usage scales with the number of conflicts, not with the number of forks","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The spoked architecture keeps the number of common ancestors low, because they aren’t needed for every single pair of forks","type":"text"}]}]}],"type":"unorderedList"}],"kind":"content"}],"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/forked\/forkedinnards"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Forked\/documentation\/Forked\/ForkedInnards"},"hierarchy":{"paths":[["doc:\/\/Forked\/documentation\/Forked"]]},"references":{"doc://Forked/documentation/Forked/CloudKitIntegration":{"abstract":[{"type":"text","text":"Learn how to use ForkedCloudKit to sync your data across devices."}],"type":"topic","url":"\/documentation\/forked\/cloudkitintegration","role":"article","identifier":"doc:\/\/Forked\/documentation\/Forked\/CloudKitIntegration","kind":"article","title":"CloudKit Integration Guide"},"doc://Forked/documentation/Forked":{"role":"collection","url":"\/documentation\/forked","abstract":[{"text":"A framework for handling shared data with confidence in Swift.","type":"text"}],"title":"Forked","type":"topic","identifier":"doc:\/\/Forked\/documentation\/Forked","kind":"symbol"},"doc://Forked/documentation/Forked/GettingStarted":{"abstract":[{"type":"text","text":"Learn how to use Forked to manage shared data in your Swift applications."}],"type":"topic","url":"\/documentation\/forked\/gettingstarted","role":"article","identifier":"doc:\/\/Forked\/documentation\/Forked\/GettingStarted","kind":"article","title":"Getting Started with Forked"},"ForkedHub":{"alt":"The hub-and-spoke architecture of Forked.","identifier":"ForkedHub","variants":[{"url":"\/images\/Forked\/ForkedHub.png","traits":["1x","light"]}],"type":"image"}}}