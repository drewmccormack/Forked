[{"kind":"symbol","summary":"","headings":[],"rawIndexableTextContent":"","title":"ForkedModel","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/ForkedModel\/documentation\/ForkedModel"},"type":"topLevelPage"}},{"kind":"symbol","title":"ForkedModel(version:)","summary":"","headings":[],"location":{"type":"topLevelPage","reference":{"url":"doc:\/\/ForkedModel\/documentation\/ForkedModel\/ForkedModel(version:)","interfaceLanguage":"swift"}},"rawIndexableTextContent":" "},{"location":{"type":"topLevelPage","reference":{"interfaceLanguage":"swift","url":"doc:\/\/ForkedModel\/documentation\/ForkedModel\/Backed(by:)"}},"kind":"symbol","title":"Backed(by:)","rawIndexableTextContent":" ","headings":[],"summary":""},{"title":"Mergeable","headings":[],"rawIndexableTextContent":" ","kind":"symbol","summary":"","location":{"reference":{"interfaceLanguage":"swift","url":"doc:\/\/ForkedModel\/documentation\/ForkedModel\/Mergeable"},"type":"topLevelPage"}},{"rawIndexableTextContent":" ","summary":"","title":"Merged(using:)","location":{"type":"topLevelPage","reference":{"url":"doc:\/\/ForkedModel\/documentation\/ForkedModel\/Merged(using:)","interfaceLanguage":"swift"}},"kind":"symbol","headings":[]},{"rawIndexableTextContent":"Create mergeable data models using Swift value types. Overview ForkedModel provides a simple way to define data models using Swift value types (ie structs), which can be safely merged when concurrent changes occur. Attaching the @ForkedModel macro to a struct, you can create a data model that can handle property-wise merging with sophisticated algorithms. A mergeable model is useful for handling concurrent changes to data within your app, between processes (eg extensions), and even between devices if you are syncing with iCloud. Adopting @ForkedModel takes very little effort, has very little risk since your model is comprised of standard structs, and prepares your app for whatever data concurrency challenges may arise. Creating a Basic Model You create a mergeable model using the @ForkedModel macro:  The attributes in this model will be merged using a “most recent wins” strategy — if both forks modify the same property, the most recent change will be kept. Note that properties will be merged in a property-wise fashion. If the name property is modified in one fork, and the age property is modified in another, the most recent of each property will be kept when merging. This is different to just choosing the most recent value of the struct, which does not consider how the individual properties have changed. The @ForkedModel macro generates a standard Swift struct with an extension that conforms to Mergeable. There is no runtime overhead or magic - just pure Swift value types with some helper functions to facilitate merging. The generated struct can be used the same as any other struct, including adding Codable conformance to save or work with a web service. Using `@Merged` Properties The @Merged macro works alongside @ForkedModel, specifying how specific properties should be merged when conflicts arise. By default, @Merged will choose an appropriate merging strategy based on the property type:  The algorithms for merging these properties are quite sophisticated. They utilize state-of-the-art algorithms known as Conflict-free Replicated Data Types (CRDTs). These algorithms aim to generate a result that is consistent with the expectations of people, rather than just convenient to program. Default Merging Strategies When using the @Merged macro, each type has a default merging algorithm, but you can also specify a different algorithm. The default merging strategies are: String properties use .textMerge Array properties use .arrayMerge Set properties use .setMerge Dictionary properties use .dictionaryMerge Types that conform to Mergeable use their own merging implementation Customizing Merge Behavior You can explicitly specify which merging algorithm to use with the using: parameter on @Merged:  Available Merge Strategies .textMerge: Intelligently merges text changes in a way people would expect .arrayMerge: Merges arrays by combining elements in an expected fashion .arrayOfIdentifiableMerge: Merges arrays of items conforming to Identifiable, ensuring uniqueness of IDs .setMerge: Merges sets using set operations, handling conflicts in a way that is consistent with expections .dictionaryMerge: Merges dictionaries by combining key-value pairs, handling conflicts in a way that is consistent with human expectations Working with Optional Properties ForkedModel handles optional properties seamlessly:  Custom Mergeable Types You can use custom types that conform to Mergeable with @Merged:  Recursive Merging Many of the merge algorithms will recursively apply merging to their contained elements if those elements conform to Mergeable. This allows for sophisticated nested data structures:  In this example, when comments are merged: .arrayOfIdentifiableMerge handles the array of comments It ensures that when multiple comments with the same ID are encountered, they are properly merged Inside each Comment, the text is merged using text merging The same principle applies to dictionary values:  When merging the dictionary, if the values for a given key are Mergeable, they will be merged recursively rather than just taking the most recent value. Model Versioning When working with models that might be shared between different versions of your app on different devices, it’s important to handle model versioning properly. The @ForkedModel macro includes support for versioning through its version parameter:  Whenever you make a change to the model, increment the version by 1. Versioning becomes crucial when: Different devices might be running different versions of your app You need to sync data between devices (e.g., via CloudKit) You want to prevent older versions of your app from trying to load data they don’t understand Adding Versioning to Existing Models If you have an existing unversioned model, it effectively has a version of 0. When adding versioning, you have two options: If your model structure hasn’t changed, keep compatibility with existing data:  If you’re changing the model structure, increment version to indicate:  Important Notes All non-optional stored properties must have default values The @ForkedModel macro automatically makes your type conform to Mergeable Properties without @Merged will use a “most recent wins” strategy, in a property-wise fashion The merging strategy is determined at compile time and cannot be changed at runtime","title":"ForkedModel","headings":["Overview","Creating a Basic Model","Using `@Merged` Properties","Default Merging Strategies","Customizing Merge Behavior","Available Merge Strategies","Working with Optional Properties","Custom Mergeable Types","Recursive Merging","Model Versioning","Adding Versioning to Existing Models","Important Notes"],"summary":"Create mergeable data models using Swift value types.","kind":"article","location":{"reference":{"url":"doc:\/\/ForkedModel\/documentation\/ForkedModel\/ForkedModel","interfaceLanguage":"swift"},"type":"topLevelPage"}}]